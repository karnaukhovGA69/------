a) a = 13 >= 1 фактор ветвления
b = 21 > 1 Коэффициент уменьшения размера
k >= 1.5
f(n) = 1 - монотонная  
 Значит можно

log21(13) < 1.5 = k => T(n) = O(n^(3/2))

b) T(n) = T(n-2) + T(n-3) + n <= 2T(n-2) + n
a = 3 > 0
b = 2 > 0
k = 1 >=0
f(n) = 1 - монотонная
Можно:

a > 1 => T(n) = O(2^(n/2) \* n ^ 1)

c) T(n) = 12\*T(n/4) + n^(7/4)

a = 12 >= 1
b = 4 > 1
k = 7/4 >= 0
f(n) = 1 - монотонна
Условия выполняются, значит можно

Применяем:
log4(12) > 7/4 => O(n^(log4(12)))

d) T(n) = 2T(n/3) + 2G(n/3) + O(1)
G(n) = 2*G(n/3) + n * sin n
ТАк так G(n) - не монотонна, то нельзя юзать мастре теорему

e)T(n) = 9 / 4 \* T(2n/3) + n^2 \* ln(n^(1/2)) \* ln(ln(n))

a = 9 / 4 >= 1
b = 3/2 >= 1
k = 2 >= 0
f(n) = ln(n^(1/2)) \* ln(ln(n)) - монотонна

Значит можем использовать
log3/2(9/4) = 2 == k => O(n^k _ ln(n^(1/2)) \* ln(ln(n)) _ log(n))

=============== ПУНКТ 2 ================
Не смогли пункт d

Щас раскидаем его

d) Для верхней оценки мы можем брать максимльные значения, то есть G(n) = 2G(n/3) + n * sin(n), мы можем спокойно сказать что n*sin(n) <= n, для верхней оценки нам это можно использовать, тогда G(n) = 2 \*G(n/3) + n

Так как каждый раз наша подзаадача ументьшаетися в 3 раза,
то тогда глубина рекурсии будет log_3(n), каждый вызов рекурсии, вызывает 2 подзадачи, значит на каждом уровне рекурсии будет 2^i вызовов

тогда сумма E\_{i=0} ^ {log*3(n)} = 2^i * n*sin(n/3^i) / 3^i => Заметим что n \* sin(n) <= n а так же что (2/3)^i всегда < 0 и тогда имеем E\_{i=0} ^ {log_3(n)} (2/3)^i * n = n \* E(2/3)^i ~ n
ИТог O(n)
Проверим через мастер теорему
a = 2 >= 1
b = 3 > 0
k = 1 > 0
f(n) - монотонная
log3(2) < 1 = k => O(n)
Тогда имеем что в T(n) = 2\* T(n/3) + O(n)

при расписывание дерева индукции, мы можем заметить, да и по формуле, что количество вызовов будет увиличиваться в 2 раза, так как коэффициент перед T = 2, значит на каждом уровне, у нас будет 2^i подзадач, так как аргумент n, уменьшается в 3 раза, то тогда глубина, ну или высота рекурсии будет log*3(n).
Можем записать через сумму
E*{i = 0}^{log_3(n)} (2^i \* n \3^i) = {из подсчета G замечаем (2/3)^i} =O()
Очень нагло хитро, проверим через матсер теорему,
a = 2 >=1
b = 3 > 1
k = 1 >= 0
f(n) - ну якобы монотонная, поверим

log3(2) < 1 = k => O(n)
сошлось ;)

Пункт 3
a) T(n) = T(n/4) + 2 T(n/16) + n _ log(n)
(Мы можем сделать так, му приводим к меньшему изменениям, то есть у нас будет T(n) = 3T(n/4) + n _ log(n))

a = 3
b = 4
k = 1

f(n) = log(n) - монотонная
log*b(a) = log4(4) < 1 = k => O(n * f(n)) = O(n \_ log(n))

Акра-баZZи:
(1/4)^p + 2 \* (1/16)^p = 1 => p = 1/2

T(n)=Θ(np(1+∫1n​up+1f(u)​du)), где f(u) = ulogu
подставляем p = 1/2 => 2sqrt(u) _ (log(u) - 2) ~~ 2sqrt(n)log(n)
Тогда имеем T(n) = O(n^(1/2) _ n^(1/2) _ log(n)) = O(n _ log(n))
ИТОГ:
СОВПАЛо ;)

b) T(n) = 3T(n/2) + 6\*T(n/5) + T(n/10) + n^2/ln(n)

Применим чудесное правило, чтобы получить T(n) = 10T(n/2)
a = 10
b = 2
k = 2
f(n) = 1/ln(n)
logb(a) = log2(10) > 3 > k = 2 => T(n) = O(n^(log2(10) \* 1/ln(n)))

Акра-баZZи:
3\*(1/2)^p + 6(1/5)^p + (1/10)^p = 1 => p = 2

T(n) = O(n^2(1+∫1n​up+1f(u)​du)) где f(u) = u^2/ln(u)
Подставляем p = 2

и получаем f(u)/u^(p+1) = 1/(u*ln(u))
∫1/(u*ln(u)) = ln(ln(n)) + C => T(n) = O(n^2(1+ln(ln(n)))) = O(n^2 _ ln(ln_(n)))

тут не совпало :(, Почему же?
ПОтому что при использоание мастер теоремы мы приходим к большему аргумент (n/2) что в разы увеличивает количество подзадач, вместо уменьшени я в 10 раз, мы уменьшаем только в 2, то есть разница в 5 раз, а при каждой итерации это уже будет 5^i, каждый раз разрыв будет увеличиваться, поэтому и ассимтотика будет больше, НО соответвено если мы ограничили Большую рекурсию, то меньбшая тем более будет ограничена этим же, да не так точно, да получается довольно грубо, но сохраняется примерный смылс, мы не уходим в какие то слишком большие ограничения, по типу 2^n, в данном случае, по мастер теореме у нас получилось ~~ n^(3.3) а по Акра-БаZZи, имеем n^2 + логарифмы, разница не критично огромная, но существенна из за огрублений в начале,
А Акра-БаZZи, учитывает различные коэффициенты, и поэтому получается ТОЧНАЯ оченка
